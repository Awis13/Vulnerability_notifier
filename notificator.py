import requests
import zipfile
import json
import io
import os
from datetime import datetime
import boto3

# Fetches the recent releases from the specified GitHub repository.
def fetch_recent_releases():
    url = "https://api.github.com/repos/CVEProject/cvelistV5/releases"
    response = requests.get(url)
    try:
        response.raise_for_status()  # This will raise an HTTPError for bad responses
    except requests.exceptions.HTTPError as err:
        print(f"HTTP error occurred: {err}")
        return []  # Return an empty list so the rest of your script can handle this case
    
    try:
        releases = response.json()
    except json.JSONDecodeError as err:
        print(f"Failed to decode JSON response: {err}")
        return []  # Return an empty list so the rest of your script can handle this case

    if not isinstance(releases, list):
        print(f"Unexpected response format: {releases}")
        return []  # Return an empty list so the rest of your script can handle this case

    print(f'Fetched {len(releases)} releases.')
    return releases

# Downloads and extracts files from the latest release, focusing on delta files.
def download_and_extract_all_files(release):
    assets = release.get('assets', [])
    for asset in assets:
        download_url = asset.get('browser_download_url')
        if download_url and download_url.endswith('.zip') and 'delta' in download_url.lower():
            print(f'Downloading {download_url}')
            response = requests.get(download_url)
            response.raise_for_status()
            with zipfile.ZipFile(io.BytesIO(response.content)) as z:
                z.extractall(path='vulnerability_files')
                print(f'Extracted {len(z.namelist())} files from {download_url}.')
        else:
            print(f'Skipping non-delta file: {download_url}')

# Filters vulnerabilities from the delta files, focusing on published ones from 2023 onwards with a CVSS base score of 5 or higher.
def filter_vulnerabilities():
    filtered_vulns = []
    path = 'vulnerability_files/deltaCves'
    for root, dirs, files in os.walk(path):
        print(f'Checking {len(files)} files in {root} for vulnerabilities.')  # Debug print
        for file in files:
            file_path = os.path.join(root, file)
            with open(file_path) as f:
                try:
                    vuln = json.load(f)
                except json.JSONDecodeError as e:
                    print(f'Error decoding JSON in {file_path}: {e}')
                    continue  # Skip to the next file

                cve_metadata = vuln.get('cveMetadata', {})
                if cve_metadata.get('state') != 'PUBLISHED':
                    print(f'Skipping unpublished vulnerability in {file_path}.')  # Debug print
                    continue

                date_updated_str = cve_metadata.get('dateUpdated', '0')
                try:
                    date_updated = datetime.fromisoformat(date_updated_str.replace('Z', '+00:00'))
                except ValueError as e:
                    print(f'Error parsing date in {file_path}: {e}')
                    continue  # Skip to the next file

                if date_updated.year < 2023:
                    print(f'Skipping outdated vulnerability in {file_path}.')  # Debug print
                    continue

                # Adjusted the data extraction based on the JSON structure
                containers = vuln.get('containers', {})
                cna = containers.get('cna', {})
                affected = cna.get('affected', [{}])[0]
                references = cna.get('references', [{}])[0]
                descriptions = cna.get('descriptions', [{}])[0]

                filtered_vulns.append({
                    'cveId': cve_metadata.get('cveId'),
                    'affectedProduct': f"{affected.get('vendor', 'n/a')} - {affected.get('product', 'n/a')}",
                    'title': descriptions.get('value'),
                    'dateUpdated': date_updated_str,
                    'link': references.get('url')
                })

    print(f'Filtered {len(filtered_vulns)} vulnerabilities.')  # Debug print
    return filtered_vulns



# Sends an email with the specified subject, body text and HTML, to and from the specified addresses.
def send_email(subject, body_text, body_html, to_addresses, from_address):
    aws_access_key_id = os.environ.get('AWS_ACCESS_KEY_ID')
    aws_secret_access_key = os.environ.get('AWS_SECRET_ACCESS_KEY')
    client = boto3.client(
        'ses',
        region_name='us-east-1',
        aws_access_key_id=aws_access_key_id,
        aws_secret_access_key=aws_secret_access_key
    )
    response = client.send_email(
        Source=from_address,
        Destination={
            'ToAddresses': to_addresses,
        },
        Message={
            'Subject': {
                'Data': subject,
            },
            'Body': {
                'Text': {
                    'Data': body_text,
                },
                'Html': {
                    'Data': body_html,
                }
            }
        }
    )
    return response

# Formats the filtered vulnerabilities into an HTML table for email.
def format_vulnerabilities(vulnerabilities):
    table_header = """
    <table border="1" style="width:100%; border-collapse:collapse; text-align:left;">
        <thead>
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px;">CVE ID</th>
                <th style="padding: 8px;">Affected Product</th>
                <th style="padding: 8px;">Title</th>
                <th style="padding: 8px;">Base Score</th>
                <th style="padding: 8px;">Date Updated</th>
                <th style="padding: 8px;">Link</th>
            </tr>
        </thead>
        <tbody>
    """

    table_rows = ""
    for vuln in vulnerabilities:
        base_score = vuln.get('baseScore', 'N/A')  # Use 'N/A' if 'baseScore' key is not present
        table_rows += f"""
        <tr>
            <td style="padding: 8px;">{vuln['cveId']}</td>
            <td style="padding: 8px;">{vuln['affectedProduct']}</td>
            <td style="padding: 8px;">{vuln['title']}</td>
            <td style="padding: 8px;">{base_score}</td>
            <td style="padding: 8px;">{vuln['dateUpdated']}</td>
            <td style="padding: 8px;"><a href="{vuln['link']}">View Details</a></td>
        </tr>
        """
    table_footer = """
        </tbody>
    </table>
    """

    html_table = table_header + table_rows + table_footer
    return html_table


# Main function to execute the entire workflow from fetching releases to sending the email.
def main():
    to_addresses = os.getenv('TO_ADDRESSES').split(',')
    from_address = os.getenv('FROM_ADDRESSES')
    subject = 'Daily Vulnerability Report'
    releases = fetch_recent_releases()
    download_and_extract_all_files(releases[0])
    filtered_vulnerabilities = filter_vulnerabilities()
    formatted_vulnerabilities = format_vulnerabilities(filtered_vulnerabilities)
    email_body_text = "This is the text version of the email content."
    email_body_html = f"<html><body>{formatted_vulnerabilities}</body></html>"
    
    send_email(subject, email_body_text, email_body_html, to_addresses, from_address)

if __name__ == "__main__":
    main()
