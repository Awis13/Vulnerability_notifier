import requests
import zipfile
import json
import io
import os
from datetime import datetime
import boto3

# Fetches the recent releases from the specified GitHub repository.
def fetch_recent_releases():
    url = "https://api.github.com/repos/CVEProject/cvelistV5/releases"
    response = requests.get(url)
    response.raise_for_status()
    return response.json()

# Downloads and extracts files from the latest release, focusing on delta files.
def download_and_extract_all_files(release):
    assets = release.get('assets', [])
    for asset in assets:
        download_url = asset.get('browser_download_url')
        if download_url and download_url.endswith('.zip') and 'delta' in download_url.lower():
            print(f'Downloading {download_url}')
            response = requests.get(download_url)
            response.raise_for_status()
            with zipfile.ZipFile(io.BytesIO(response.content)) as z:
                z.extractall(path='vulnerability_files')
        else:
            print(f'Skipping non-delta file: {download_url}')

# Filters vulnerabilities from the delta files, focusing on published ones from 2023 onwards with a CVSS base score of 5 or higher.
def filter_vulnerabilities():
    filtered_vulns = []
    for root, dirs, files in os.walk('vulnerability_files/deltaCves'):
        for file in files:
            with open(os.path.join(root, file)) as f:
                vuln = json.load(f)
                cve_metadata = vuln.get('cveMetadata', {})
                if cve_metadata.get('state') != 'PUBLISHED':
                    continue

                date_updated_str = cve_metadata.get('dateUpdated', '0')
                date_updated = datetime.fromisoformat(date_updated_str.replace('Z', '+00:00'))
                if date_updated.year < 2023:
                    continue

                containers = vuln.get('containers', {})
                cna = containers.get('cna', {})
                metrics_list = cna.get('metrics', [])
                for metrics in metrics_list:
                    cvss_v3_1 = metrics.get('cvssV3_1', {})
                    base_score = cvss_v3_1.get('baseScore', 0)
                    
                    if base_score >= 5:
                        affected = cna.get('affected', [{}])[0]
                        filtered_vulns.append({
                            'cveId': cve_metadata.get('cveId'),
                            'affectedProduct': f"{affected.get('vendor', 'n/a')} - {affected.get('product', 'n/a')}",
                            'title': cna.get('descriptions', [{}])[0].get('value'),
                            'baseScore': base_score,
                            'dateUpdated': date_updated_str,
                            'link': cna.get('references', [{}])[0].get('url')
                        })
    return filtered_vulns

# Sends an email with the specified subject, body text and HTML, to and from the specified addresses.
def send_email(subject, body_text, body_html, to_addresses, from_address):
    aws_access_key_id = os.environ.get('AWS_ACCESS_KEY_ID')
    aws_secret_access_key = os.environ.get('AWS_SECRET_ACCESS_KEY')
    client = boto3.client(
        'ses',
        region_name='us-east-1',
        aws_access_key_id=aws_access_key_id,
        aws_secret_access_key=aws_secret_access_key
    )
    response = client.send_email(
        Source=from_address,
        Destination={
            'ToAddresses': to_addresses,
        },
        Message={
            'Subject': {
                'Data': subject,
            },
            'Body': {
                'Text': {
                    'Data': body_text,
                },
                'Html': {
                    'Data': body_html,
                }
            }
        }
    )
    return response

# Formats the filtered vulnerabilities into an HTML table for email.
def format_vulnerabilities(vulnerabilities):
    table_header = """
    <table border="1" style="width:100%; border-collapse:collapse; text-align:left;">
        <thead>
            <tr style="background-color: #f2f2f2;">
                <th style="padding: 8px;">CVE ID</th>
                <th style="padding: 8px;">Affected Product</th>
                <th style="padding: 8px;">Title</th>
                <th style="padding: 8px;">Base Score</th>
                <th style="padding: 8px;">Date Updated</th>
                <th style="padding: 8px;">Link</th>
            </tr>
        </thead>
        <tbody>
    """

    table_rows = ""
    for vuln in vulnerabilities:
        table_rows += f"""
        <tr>
            <td style="padding: 8px;">{vuln['cveId']}</td>
            <td style="padding: 8px;">{vuln['affectedProduct']}</td>
            <td style="padding: 8px;">{vuln['title']}</td>
            <td style="padding: 8px;">{vuln['baseScore']}</td>
            <td style="padding: 8px;">{vuln['dateUpdated']}</td>
            <td style="padding: 8px;"><a href="{vuln['link']}">View Details</a></td>
        </tr>
        """
    table_footer = """
        </tbody>
    </table>
    """

    html_table = table_header + table_rows + table_footer
    return html_table

# Main function to execute the entire workflow from fetching releases to sending the email.
def main():
    to_addresses = os.getenv('TO_ADDRESSES').split(',')
    from_address = os.getenv('FROM_ADDRESSES')
    subject = 'Daily Vulnerability Report'
    releases = fetch_recent_releases()
    download_and_extract_all_files(releases[0])
    filtered_vulnerabilities = filter_vulnerabilities()
    formatted_vulnerabilities = format_vulnerabilities(filtered_vulnerabilities)
    email_body_text = "This is the text version of the email content."
    email_body_html = f"<html><body>{formatted_vulnerabilities}</body></html>"
    
    send_email(subject, email_body_text, email_body_html, to_addresses, from_address)

if __name__ == "__main__":
    main()
